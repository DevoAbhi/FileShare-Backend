API data

v1/job/upload - POST
companyId: 
fileUrl : https://stream.vanna.io/baf5cd9f-fb4b-465f-887b-786538b4cd55

1. Download file
2. Convert csv to json - https://www.npmjs.com/package/csvtojson
3. [
	{
		job_title: ""
		companyId
	},
	{
		job_title: "",
		companyId
	}
]
4. Iterate row items and insert into the DB


The job.ts file for testing -> 


import { IJob, Job, Company, JobApplication, ICompany, CompanyFollow } from "../../lib/models";
import { PathParam } from "../../lib/types";
import { LambdaLogic } from "../../lib/types/AWS";
import { SQSHandler } from 'aws-lambda';
import { SQS } from 'aws-sdk';
import { getjobType, jobTypes, jobUploadType } from "../../lib/types/job";
import { handlerWrapper, HttpError, JOB_EXISTS, JOB_NOT_EXISTS, COMPANY_NOT_EXISTS, JOB_UPLOAD_NOT_EXISTS } from "../../lib/utils";
import { createJobSchema, updateJobSchema, getComanyWiseLatestJobsSchema } from "./validator";
import { PaginateOptions} from "mongoose";
import { getJobtListSchema } from "./validator/getJobs";
import { v4 } from "uuid";
import { DEFAULT_COMPANY_WISE_JOB, DEFAULT_TOP_COMPANY_LIST } from "../../lib/config/constant";
import { isValidObjectId } from "mongoose";
import { IJobUpload, JobUpload } from "../../lib/models/JobUpload";
const request = require('request')
const csv = require('csvtojson')
import { createJobPermission, JobByIdPermission, jobOpenAPIPermission } from "./permission";
import { ENVS } from "../../lib/common/envs";
import { notifyGoogle } from "./googleJobPost";


type uploadType = { 
    companyId: string, 
    fileUrl: string, 
    identifier: string, 
    createdBy: string, 
    updatedBy: string 
}

const create: LambdaLogic<{}, jobTypes> = async event => { 
    
    const payload: jobTypes = event.body;
    const company: ICompany = await Company.findById(payload.companyId).select("name").lean();
    if(!company) throw new HttpError().BadRequest(COMPANY_NOT_EXISTS);
    const jobData = {
        company: company,
        title: payload.title
    }
    const jobDetails = await createHelper(jobData);
    const jobId = jobDetails.jobId;
    const slug = jobDetails.slug;
    const data = { ...payload, jobId, createdBy: event.user.id , updatedBy: event.user.id, slug, status: "New"};
    let job: IJob = new Job(data);
    await job.save();
    try{
        await notifyGoogle(`${ENVS.FE_URL}/${job.slug}`, "URL_UPDATED");
    }
    catch(err){
        console.log(err.stack)
    }
    return job;
}

const createHelper = async (data: {company: ICompany, title: string}): Promise<{jobId: string,slug: string}> => {
    
    const jobId: string = v4();
    let slug = `${data.company.name}-${data.title}-${jobId}`
    const jobDetails = {
        jobId: jobId,
        slug: slug
    }
    return jobDetails;
}

const uploadJobsFunc: LambdaLogic<{}, uploadType, {}> = async (event) => {
    const companyId = event.body.companyId;
    const fileUrl = event.body.fileUrl;
    const identifier: string = v4();
    const uploadJobsData: jobUploadType = {
        companyId: companyId,
        fileUrl: fileUrl,
        createdBy: event.user.id,
        updatedBy: event.user.id,
        success: false,
        successCount: 0,
        failureCount: 0,
        totalCount: 0,
        status: "In-Progress",
        identifier: identifier
    }

    console.log("Saved identifier", identifier);

    const uploadJobs: IJobUpload = new JobUpload(uploadJobsData);
    await uploadJobs.save();

    const sqs = new SQS({ region: process.env.DEPLOYMENT_REGION, endpoint: "http://localhost:9324" });

    let messageObj = {
        companyId: event.body.companyId,
        fileUrl: event.body.fileUrl,
        createdBy: event.user.id,
        updatedBy: event.user.id,
        identifier: identifier
    }
    const response = await sqs.sendMessage({
        MessageBody: JSON.stringify(messageObj),
        QueueUrl: 'http://localhost:9324/981477912451/queue1'
    }).promise();
    console.log("SQS Response", JSON.stringify(response));

    console.log("Sent identifier", identifier)
    // const response = await sqs.sendMessage({
    //     MessageBody: JSON.stringify(messageObj),
    //     QueueUrl: 'https://sqs.ap-southeast-1.amazonaws.com/981477912451/Spider_Job_File_Processing'
    // }).promise();
    // var params = {
    //     QueueName: 'queue1',
    //     QueueOwnerAWSAccountId: '981477912451'
    //   };
    // const queueUrl = sqs.getQueueUrl(params, (err, data) => {
    //     console.log(data)
    // })
    var params = {
        AttributeNames: [
            "SentTimestamp"
         ],
         MaxNumberOfMessages: 10,
         MessageAttributeNames: [
            "All"
         ],
         QueueUrl: 'http://localhost:9324/981477912451/queue1',
         VisibilityTimeout: 20,
         WaitTimeSeconds: 10
        // MessageAttributeNames: [
        // //   'STRING_VALUE',
        // //   /* more items */
        // ],
        // // ReceiveRequestAttemptId: '00000000-0000-0000-0000-000000000000',
        // VisibilityTimeout: 20,
        // WaitTimeSeconds: 40
      };
      const receivedMessage: any = sqs.receiveMessage(params).promise();
      console.log(await receivedMessage)

    const jobUploadData = JSON.parse((await receivedMessage).Messages[0].Body)
    console.log(jobUploadData)

        const receivedCompanyId = jobUploadData.companyId;
        const receivedFileUrl = jobUploadData.fileUrl;
        const createdBy = jobUploadData.createdBy;
        const updatedBy = jobUploadData.updatedBy;
        const receivedIdentifier = jobUploadData.identifier;

        console.log("Received identifier", receivedIdentifier);

        let successCount: number = 0;
        let failureCount: number = 0;
        let totalCount: number = 0;
        const company: ICompany = await Company.findById(receivedCompanyId).select("name").lean();
        if(!company) throw new HttpError().BadRequest(COMPANY_NOT_EXISTS);

        const jsonArr = await csv().fromStream(request.get(receivedFileUrl));
        if(!jsonArr){
            const updateBody = {
                success: false,
                status: "Failed"
            }
            const job_upload_update = await JobUpload.findOneAndUpdate({identifier: receivedIdentifier }, { $set: { ...updateBody } }, {new: true, lean: true});
            if(!job_upload_update || job_upload_update.identifier != receivedIdentifier) {
                console.log("From first here!")
                throw new HttpError().BadRequest(JOB_UPLOAD_NOT_EXISTS);
            }
        }
        for (const jobObj of jsonArr) {
            try{
                const jobData = {
                    company: company,
                    title: jobObj.job_title
                }
                const jobDetails = await createHelper(jobData)
                const skills = {
                    category: jobObj.category,
                    job_type: jobObj.job_type
                }
                const data: jobTypes = {
                    title: jobObj.job_title,
                    description: jobObj.job_description,
                    type: 'Permanent',
                    external: true,
                    external_job_ref: jobObj.job_ref,
                    external_job_url: jobObj.job_URL,
                    external_id: jobObj.ID,
                    location: [jobObj.location],
                    jobId: jobDetails.jobId,
                    skills: [skills],
                    status: "New",
                    companyId: receivedCompanyId,
                    createdBy: createdBy,
                    updatedBy: updatedBy,
                    slug: jobDetails.slug,
                }
                    
                let job: IJob = new Job(data);
                await job.save();
                successCount += 1;
            }
            catch(err){
                failureCount += 1;
                console.log(err);
            }
        }

        totalCount = successCount + failureCount;
        const updatebody = {
            success: true,
            successCount: successCount,
            failureCount: failureCount,
            totalCount: totalCount,
            status: "Processed"
        }

        const job_upload_update = await JobUpload.findOneAndUpdate({identifier: receivedIdentifier }, { $set: { ...updatebody } }, {lean: true});
        // new: true,
        if(!job_upload_update || job_upload_update.identifier != receivedIdentifier) {
            console.log("From Second here!")
            throw new HttpError().BadRequest(JOB_UPLOAD_NOT_EXISTS);
        }


    for (const message of (await receivedMessage).Messages) {
        var deleteParams = {
            QueueUrl: 'http://localhost:9324/981477912451/queue1', /* required */
            ReceiptHandle: message.ReceiptHandle /* required */
          };
          sqs.deleteMessage(deleteParams, function(err, data) {
            if (err) console.log(err, err.stack); // an error occurred
            else     console.log("Deleted message : ",data);           // successful response
          });
    }
    return { message: "Job Uploading in progress" }

}

const getJob: LambdaLogic<{}, {}, PathParam> = async event => {
    const { pathParameters } = event;
    let query = {};
    if(isValidObjectId(pathParameters.id)){
        query = {_id: pathParameters.id}
    }
    else{
        query = {slug: decodeURIComponent(pathParameters.id)}
    }
    const jobRes: any = await Job.findOne(query).populate([{path: 'companyId', select: 'name logo slug'}]).lean();
    if (!jobRes) throw new HttpError().BadRequest(JOB_NOT_EXISTS);
    if(event?.user && await JobApplication.exists({userId: event.user.id, jobId: jobRes._id})){
        jobRes.isUserApplied = true;   
    }
    return jobRes;
}

const update: LambdaLogic<{}, jobTypes, PathParam> = async event =>{
    let body = {...event.body, updatedBy: event.user.id};
    const job_update = await Job.findOneAndUpdate({_id: event.pathParameters.id }, { $set: { ...body } }, {new: true, lean: true});
    if (!job_update) throw new HttpError().BadRequest(JOB_NOT_EXISTS);
    if(body.status == "Closed"){
        try{
            await notifyGoogle(`${ENVS.FE_URL}/${job_update.slug}`, "URL_DELETED");
        }
        catch(err){
            console.log(err.stack)
        }
    }
    else{
        try{
            await notifyGoogle(`${ENVS.FE_URL}/${job_update.slug}`, "URL_UPDATED");
        }
        catch(err){
            console.log(err.stack)
        }
    }
    return job_update;
}

const getList: LambdaLogic<getjobType> = async event => {
    let { q, status, page, limit, companyId, skills, types, locations, fromDate, toDate } = event.queryStringParameters;
    let sortQ: any = {
        createdAt: -1
    };
    let query: any = {};
    let populate = [
        { path: "companyId", select: "name logo slug isPublic" }
    ]
    if (companyId) {
        query.companyId = companyId
    }
    
    if (status) {
        try{
            query.status = {$in: JSON.parse(status)}
        }
        catch(err){
            throw err;
        }
    }
    if (skills) {
        try{
            query.skills = {$in: JSON.parse(skills)}
        }
        catch(err){
            throw err;
        }
    }
    if (types) {
        try{
            query.type = {$in: JSON.parse(types)}
        }
        catch(err){
            throw err;
        }
    }

    if (locations) {
        try{
            query.location = {$in: JSON.parse(locations)}
        }
        catch(err){
            throw err;
        }
    }

    if(fromDate || toDate){
        if(fromDate && toDate){
            let endDate = new Date(toDate);
            endDate.setDate(endDate.getDate() + 1);
            query.createdAt = { $gte: new Date(fromDate), $lt: endDate }
        }
        else if(fromDate){
            query.createdAt = { $gte: new Date(fromDate) }
        }
        else if(toDate){
            let endDate = new Date(toDate);
            endDate.setDate(endDate.getDate() + 1);
            query.createdAt = { $lt: toDate }
        }
    }

    if (q) {
        query["$or"] = [
            { title: { $regex: q, $options: 'i' } },
            { skills: { $regex: q, $options: 'i' } },
        ]
    }
    const options: PaginateOptions = {
        page: page || 1,
        limit: limit || 10,
        sort: sortQ,
        select: "-deleted -__v",
        lean: true,
        populate
    }
    let result: any =  await Job.paginate(query, options);
    if(event && event.user && event.user.id && result && result.docs && result.docs.length){
        let jobsId = result.docs.map((d:any) => d._id);
        let ja = await getAppliedJobs(event.user.id, jobsId);
        result.docs.forEach((element:any) => {
            if(ja.hasOwnProperty(element._id.toString())) element.isUserApplied = true;
        });
    }
    return result;
}


const getComanyWiseLatestJobs: LambdaLogic<{limit:number}> = async event => {
    let aggregateQuery = [
        { $group: {
            _id: "$companyId" ,
            lastJobId: { $last: "$_id" }
        } },
        { $limit: DEFAULT_COMPANY_WISE_JOB }
    ]
    let result: any = await Job.aggregate(aggregateQuery);
    if(!result || !result.length) return [];
    if(result && result.length >= DEFAULT_COMPANY_WISE_JOB){
        return result;
    }
    let populate = [
        { path: "companyId", select: "name logo slug" }
    ]
    let availableJobsId = result.map((r:any) => r.lastJobId);
    let remainingJobs = await Job.find({_id:{$nin: availableJobsId}}).populate(populate).sort({_id:-1}).limit(DEFAULT_COMPANY_WISE_JOB - availableJobsId.length);
    let availableJobs = await Job.find({_id:{$in: availableJobsId}}).populate(populate);
    return [...remainingJobs, ...availableJobs];
}

const getTopCompany: LambdaLogic<{limit:number}> = async event => {
    let aggregateQuery = [
        { $group: {
            _id: "$companyId" ,
            count: { $sum: 1 }
        } },
        { $sort: { "count": 1} },
        { $limit: DEFAULT_TOP_COMPANY_LIST}
    ]
    let result: any = await Job.aggregate(aggregateQuery);
    if(!result || !result.length) return [];
    let companyIds = result.map((c:any) => c._id);
    let companies = await Company.find({_id: {$in: companyIds}}).lean().select("name logo slug isPublic");
    if(event.user?.id && companies.length) {
        let companyIds = companies.map((c:any) => c._id);
        let cf: any = await CompanyFollow.find({ userId: event.user.id, companyId:  { $in: companyIds }});
        cf = cf.reduce((cf: any, ccf: any)=> (cf[ccf.companyId.toString()]=ccf,cf),{});
        companies.forEach((c: any) => (cf.hasOwnProperty(c._id.toString()))? c.isFollowing = true: "");
    }
    return companies;
}

const getAppliedJobs = async (userId: string, jobsId: [string]) => {
    let result:any = {};
    let ja = await JobApplication.find({userId, jobId: { $in: jobsId }}).select("_id jobId").lean();
    ja.forEach((j:any) => {
        result[j.jobId.toString()] = j
    })
    return result;
}

export const uploadJobsSQS : SQSHandler = async (event) => {

    try{
        const sqs = new SQS({ region: process.env.DEPLOYMENT_REGION });
        console.log(event.Records)
        
        for (const record of event.Records){
            let jobUploadData: uploadType = JSON.parse(record.body);
            console.log(jobUploadData)

            const companyId = jobUploadData.companyId;
            const fileUrl = jobUploadData.fileUrl;
            const createdBy = jobUploadData.createdBy;
            const updatedBy = jobUploadData.updatedBy;
            const identifier = jobUploadData.identifier;

            let successCount: number = 0;
            let failureCount: number = 0;
            let totalCount: number = 0;
            const company: ICompany = await Company.findById(companyId).select("name").lean();
            if(!company) throw new HttpError().BadRequest(COMPANY_NOT_EXISTS);

            const jsonArr = await csv().fromStream(request.get(fileUrl));
            if(!jsonArr){
                const updateBody = {
                    success: false,
                    status: "Failed"
                }
                const job_upload_update = await JobUpload.findOneAndUpdate({identifier: identifier }, { $set: { ...updateBody } }, {lean: true});
                if(!job_upload_update || job_upload_update.identifier != identifier) throw new HttpError().BadRequest(JOB_UPLOAD_NOT_EXISTS);
            }
            for (const jobObj of jsonArr) {
                try{
                    const jobData = {
                        company: company,
                        title: jobObj.job_title
                    }
                    const jobDetails = await createHelper(jobData)
                    const skills = {
                        category: jobObj.category,
                        job_type: jobObj.job_type
                    }
                    const data: jobTypes = {
                        title: jobObj.job_title,
                        description: jobObj.job_description,
                        type: 'Permanent',
                        external: true,
                        external_job_ref: jobObj.job_ref,
                        external_job_url: jobObj.job_URL,
                        external_id: jobObj.ID,
                        location: [jobObj.location],
                        jobId: jobDetails.jobId,
                        skills: [skills],
                        status: "New",
                        companyId: companyId,
                        createdBy: createdBy,
                        updatedBy: updatedBy,
                        slug: jobDetails.slug,
                    }
                        
                    let job: IJob = new Job(data);
                    await job.save();
                    successCount += 1;
                }
                catch(err){
                    failureCount += 1;
                    console.log(err);
                }
            }

            totalCount = successCount + failureCount;
            const updatebody = {
                success: true,
                successCount: successCount,
                failureCount: failureCount,
                totalCount: totalCount,
                status: "Processed"
            }

            const job_upload_update = await JobUpload.findOneAndUpdate({identifier: identifier }, { $set: { ...updatebody } }, {lean: true});
            if(!job_upload_update || job_upload_update.identifier != identifier) throw new HttpError().BadRequest(JOB_UPLOAD_NOT_EXISTS);

            var deleteParams = {
                QueueUrl: 'https://sqs.ap-southeast-1.amazonaws.com/981477912451/Spider_Job_File_Processing',
                ReceiptHandle: record.receiptHandle
              };
              sqs.deleteMessage(deleteParams, function(err, data) {
                if (err) console.log(err, err.stack);
                else     console.log("Deleted message : " ,data);
              });
        }
    }
    catch(err){
        console.log(err.stack)
        throw new Error(err);
    }

}

export const createJob = handlerWrapper(create, createJobSchema, createJobPermission);
export const uploadJobs = handlerWrapper(uploadJobsFunc);
export const getJobById = handlerWrapper(getJob, undefined, JobByIdPermission);
export const updateJobById = handlerWrapper<{},jobTypes, PathParam>(update, updateJobSchema, JobByIdPermission);
export const getJobList = handlerWrapper(getList, getJobtListSchema, jobOpenAPIPermission)
export const getCompanyWiseLatestJobList = handlerWrapper(getComanyWiseLatestJobs, getComanyWiseLatestJobsSchema, jobOpenAPIPermission)
export const getTopCompanyList = handlerWrapper(getTopCompany, getComanyWiseLatestJobsSchema, jobOpenAPIPermission)


// "fileUrl": "https://stream.vanna.io/0fa434a8-0c8f-4e1a-be2a-6dec85ea88bc"