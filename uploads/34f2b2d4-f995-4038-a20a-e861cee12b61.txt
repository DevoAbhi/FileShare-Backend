Email lower case login and signup

import { handlerWrapper } from '../../lib/utils/handlerWrapper';
import { LambdaLogic } from '../../lib/types/AWS';
import { HttpError, jwtHelper } from '../../lib/utils';
import { User, IUser, UserActivation } from "../../lib/models";
import bcrypt from "bcryptjs";
import { R } from '../../lib/utils';
import { USER_EXISTS, INVALID_ACTIVATION_CODE, ACTIVATION_CODE_VERIFIED, USER_NOT_EXISTS, USER_ALREADY_ACTIVATED, USER_ROLE_CREATION_NOT_ALLOWDD } from '../../lib/utils'
import { updateUserSchema, createInitialUserSchema, getListSchema, userCheckSchema, userVerifySchema } from './validators';
import { createUserTypes, updateUserBodyTypes, userTokenType } from '../../lib/types';
import { PaginateOptions } from "mongoose";
import { sendTemplateMail } from "../../lib/utils/sendMail";
import { uuid } from 'uuidv4';
import { roleAccess } from '../../lib/common/constants';
import { isValidObjectId } from "mongoose";

const disAllowedKeys = ['__v', 'password'];
const create: LambdaLogic<{}, createUserTypes> = async event => {
    var payload: createUserTypes = event.body;
    payload.status = "Pending";
    payload.email = payload.email.toLowerCase();
    if(payload?.password) payload.password = await bcrypt.hashSync(payload.password, 8);
    const userInDB: IUser | null = await User.findOne({ email: payload.email })
    if (userInDB) throw new HttpError().BadRequest(USER_EXISTS);
    let user: IUser = await createUser(payload, event.user);
    //await generateActivationAndSendEmail(user._id);
    let token = await jwtHelper.createToken(user)
    return { token, user: R.filterFields(user.toObject(), disAllowedKeys) }
}

const get: LambdaLogic<{ userId: string, username: string }> = async event => {
    const { userId, username } = event.queryStringParameters;
    let query: any = {};
    if(userId && isValidObjectId(userId)){
        query = {_id: userId}
    }
    else if(username){
        query = {username: decodeURIComponent(username) }
    }
    else{
        query = {_id: event.user.id}
    }
    const userRes: IUser | null = await User.findOne(query);
    if (!userRes) throw new HttpError().BadRequest(USER_NOT_EXISTS);
    if(userId || username){
        disAllowedKeys.push(...["email", "status", "sso", "createdAt", "updatedAt", "role", "deleted", "companyId"])    
    }
    return R.filterFields(userRes.toObject(), disAllowedKeys)
}

const getList: LambdaLogic<{ q: string, page: number, limit: number }> = async event => {
    let { q, limit, page } = event.queryStringParameters;
    let query: any = {};
    if (q && q != "") {
        query["$or"] = [
            { username: { $regex: q, $options: 'i' } },
            { fullName: { $regex: q, $options: 'i' } },
        ]
    }
    let sort = {
        createdAt: -1
    }
    const options: PaginateOptions = {
        page: Number(page) || 1,
        limit: Number(limit) || 10,
        sort,
        select: "fullName profileImg username",
        lean: true
    }
    const usersRes = await User.paginate(query, options);
    return usersRes;
}

const update: LambdaLogic<{}, updateUserBodyTypes> = async event => {
    const { body, user } = event;
    if (body.password) {
        body.password = await bcrypt.hashSync(body.password, 8);
    }
    
    if (body.dob) {
        var today = new Date();
        var birthDate = new Date(body.dob);
        var age = today.getFullYear() - birthDate.getFullYear();
        var m = today.getMonth() - birthDate.getMonth();
        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
            age = age - 1;
        }
        body.age = age
    }
    const user_update = await User.findOneAndUpdate({ _id: user.id }, { ...body }, { new: true, lean: true });
    if (!user_update) throw new HttpError().BadRequest();
    return R.filterFields(user_update, disAllowedKeys);
}

const userCheck: LambdaLogic<{username: string}> = async event => {
    const { username } = event.queryStringParameters;
    return {exists: await User.exists({username: username})};
}

const createActivation: LambdaLogic = async event => {
    try{
        let userId = event.user.id;
        await generateActivationAndSendEmail(userId);
        return { success: true }
    }
    catch(err){
        console.log(err?err.stack:err);
    }
}

const verify: LambdaLogic<{},{key: string}> = async event => {
    let { key } = event.body;
    let activation = await UserActivation.findOne({key}).lean();
    if(!activation) throw new HttpError().BadRequest(INVALID_ACTIVATION_CODE);
    if(activation.verified) throw new HttpError().BadRequest(ACTIVATION_CODE_VERIFIED);
    let user = await User.findOneAndUpdate({_id: activation.userId}, { $set: { status: "Active" } }, { new: true, lean: true });
    if(!user) throw new HttpError().BadRequest(USER_NOT_EXISTS);
    await UserActivation.updateOne({key}, { $set: { verified: true } });
    return { success: true }
}

const generateActivationAndSendEmail = async (userId: string) => {
    let user = await User.findById(userId).select('email ').lean();
    if(!user) throw new HttpError().BadRequest(USER_NOT_EXISTS);
    if(user.status == "Active") throw new HttpError().BadRequest(USER_ALREADY_ACTIVATED);
    if(!user.email) return;
    
    //Generate activation record
    let userActivation = new UserActivation({ userId, key: uuid() });
    userActivation = await userActivation.save();

    //Send email
    let data = {
        email: user.email,
        activationLink: `${process.env.WEB_URL}${userActivation.key}`
    };
    let to = [user.email];
    await sendTemplateMail(to, data, "AccountActivation");
}

export const createUser = async (userObj: createUserTypes, authUser?: userTokenType): Promise<IUser> => {
    if(!userObj.username){
        userObj.username = await getUniqueUserName(userObj.email?userObj.email.substring(0, userObj.email.indexOf("@")):`user_${Date.now()}`, 0);
    }
    if(authUser && userObj.role && (!roleAccess[authUser.role] || roleAccess[authUser.role].indexOf(userObj.role) == -1)) {
        throw new HttpError().BadRequest(USER_ROLE_CREATION_NOT_ALLOWDD);
    }
    let user = new User(userObj);
    await user.save();
    return user;
}

const getUniqueUserName = async (str: string, i: number): Promise<string> => {
    let isUserExists = await User.exists({username:`${str}${(i?i:"")}`});
    if(!isUserExists) return `${str}${(i?i:"")}`;
    i++;
    return await getUniqueUserName(`${str}`, i);
}

export const createInitialUser = handlerWrapper(create, createInitialUserSchema);
export const getUser = handlerWrapper(get);
export const getUserList = handlerWrapper(getList, getListSchema);
export const updateUser = handlerWrapper(update, updateUserSchema);
export const usernameCheck = handlerWrapper(userCheck, userCheckSchema);
export const sendActivationEmail = handlerWrapper(createActivation);
export const verifyUser = handlerWrapper(verify, userVerifySchema);










"@superawesome/permissions": "1.0.3",
    "apple-auth": "^1.0.7",
    "axios": "0.21.1",
    "bcryptjs": "2.4.3",
    "googleapis": "73.0.0",
    "http-status-codes": "2.1.4",
    "joi": "17.3.0",
    "jsonwebtoken": "8.5.1",
    "lodash": "4.17.20",
    "middy": "0.36.0",
    "middy-middleware-warmup": "1.0.3",
    "mongoose": "5.12.3",
    "mongoose-delete": "0.5.3",
    "mongoose-paginate-v2": "1.3.13",
    "query-string": "6.13.8",
    "ramda": "0.27.1",
    "source-map-support": "0.5.19",
    "stripe": "8.137.0",
    "url-slug": "^3.0.2",
    "uuidv4": "6.2.6"
